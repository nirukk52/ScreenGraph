---
alwaysApply: true
---

This document is personally managed by the founder. Keep it short clear to the point and always bulletpoints/surgical edits.

# Founder Rules
Architecture & Boundary Rules
Backend (backend/) and frontend (frontend/) are completely independent services.
No root-level coupling: root only holds docs and Git config.
No shared code or node_modules between backend and frontend.
No root package.json or encore.app`.
Backend never imports frontend; frontend never touches backend code.

## Non Negotiable Coding Rules:

### Naming
Function, Class and Folder naming is the most important thing. 
Functions should be named with descriptive, unambiguous, verb phrases that clearly state their purpose and action.
Use Verbs and Verb Phrases: Functions perform actions, so their names should reflect this. Begin function names with a verb that describes the operation, such as calculate, fetch, save, handle, get, or set.
Be Specific and Descriptive: The name should precisely indicate what the function does. Avoid generic names like handle() or process(). Instead, specify the action and the object it acts upon.
Class names should be descriptive, singular nouns or noun phrases that represent the object or concept the class models. 
Class and function names should be domain-oriented, not just technology-oriented. They should describe the real-world concept or business function, not the implementation details.
Avoid names like Hasher, Mapper, Processor, or Manager as standalone names. Instead, prefix them with the specific business concept they operate on.

### Other
Every function class enum dto will have a comment about his purpose in the codebase.
Absolutely no use of any is allowed in the codebase.
Every class, function, or API endpoint must explicitly use typed DTOs (Data Transfer Objects).
DTOs must be defined at the top of the file or imported from a shared contracts or types package.
If dynamic data is expected, define a union or discriminated type instead of fallback to any.
Temporary "loose" types must still be represented as { [key: string]: unknown } or Record<string, unknown> — never any.
No magic strings for identifiers or states — define literal unions or enums.
Prefer discriminated unions or enums over free-form string comparisons in control flow.
NO MAGIC STRINGS!
NO MAGIC NUMBERS!

### Spelling & Language
Use American English spelling exclusively across ALL code, schemas, types, comments, and docs.
Examples: "canceled" not "cancelled", "color" not "colour", "optimize" not "optimise".
This applies to: variable names, function names, enum values, database columns, type names, comments, documentation.

Logging Rules:
Use ONLY encore.dev/log for all logging — never console.log, never stdout.
Always create contextual loggers via log.with({ module, actor, runId?, workerId?, nodeName?, stepOrdinal?, eventSeq? }).
Every log payload must remain structured JSON; attach additional data as objects, never unstructured strings.
Include stopReason and err.* fields on failures; capture snapshot state when transitions occur.
NO console.log — structured Encore logs only.

Type Safety Rules
Always use Encore generated clients (~encore/clients).
Never use manual fetch() calls.
After backend API changes → run bun run gen on frontend.
Generated clients guarantee full end-to-end type safety.

Package Management
Use Bun everywhere ("packageManager": "bun").
Each sub-directory manages its own dependencies.

Testing:
You test for flow reliability, correctness, and creative consistency, not just functional output. You focus on high level flow tests and not edge cases or petty tests.

Commands:
Backend: encore run
Frontend: bun run dev

Directory Structure
/ScreenGraph
├── backend/   ← Encore backend (independent)
│   ├── encore.app
│   ├── package.json
│   └── bun.lock
├── frontend/  ← SvelteKit frontend (independent)
│   ├── package.json
│   └── bun.lock
└── README.md  ← Docs only, shared tsconfig, biome config

Build & Deployment Rules
Backend builds via Encore Cloud CI (don’t script builds manually).
Frontend builds with vite build.
Deploy independently (Encore Cloud for backend, Vercel for frontend).

Run Discipline
cd backend && encore run
cd frontend && bun run dev

Absolute Prohibitions
No root package.json
No root encore.app
No shared node_modules
No backend↔frontend imports
No manual HTTP fetches

Why This Matters
Isolation → Clean Deployment
Type Safety → Zero API Drift
Encapsulation → Predictable CI
Clarity → Easy Onboarding & Maintenance

- Maintain a `BACKEND_HANDOFF.md` and `FRONTEND_HANDOFF.md` at root.