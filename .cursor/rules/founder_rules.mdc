---
alwaysApply: true
description: "Non-negotiable development standards for ScreenGraph. Enforces architecture boundaries, naming conventions, type safety, American English spelling, logging standards, package management, and multi-agent worktree isolation policies."
---

# Founder Rules â€” ScreenGraph Development Standards

> **Purpose**: Non-negotiable rules for all development. Enforce isolation, type safety, naming standards, and multi-agent worktree discipline.

---

## ğŸ“‘ Table of Contents

### Part I: Core Coding Standards
1. [Architecture & Boundaries](#architecture--boundaries)
2. [Naming Conventions](#naming-conventions-critical)
3. [Type Safety](#type-safety-no-exceptions)
4. [Documentation & Comments](#documentation--comments)
5. [No Magic Strings/Numbers](#no-magic-stringsnumbers)
6. [Spelling & Language](#spelling--language)
7. [Logging Standards](#logging-standards)
8. [Testing Philosophy](#testing-philosophy)
9. [API Clients](#api-clients)
10. [Package Management](#package-management)
11. [Commands](#commands)
12. [Build & Deployment](#build--deployment)
13. [Handoff Documentation](#handoff-documentation)

### Part II: Environment Policy
14. [Single Environment Execution](#single-environment-execution)
15. [Worktree Usage](#worktree-usage)
16. [Standard Ports](#standard-ports)
17. [Cursor Modes](#cursor-dropdown-modes)
18. [Enforcement Rules](#enforcement-what-agents-cannot-do)

---

## Part I: Core Coding Standards (ALWAYS)

### ğŸ—ï¸ Architecture & Boundaries

**Backend/Frontend Separation:**
- Backend (`backend/`) and frontend (`frontend/`) are completely independent services
- No shared code or `node_modules` between them
- No root `package.json` or `encore.app`
- Backend never imports frontend; frontend never touches backend code
- No root-level coupling: root only holds docs and Git config

**Directory Structure:**
```
/ScreenGraph
â”œâ”€â”€ backend/          â† Encore backend (independent)
â”‚   â”œâ”€â”€ encore.app
â”‚   â”œâ”€â”€ package.json
â”‚   â””â”€â”€ bun.lock
â”œâ”€â”€ frontend/         â† SvelteKit frontend (independent)
â”‚   â”œâ”€â”€ package.json
â”‚   â””â”€â”€ bun.lock
â””â”€â”€ README.md         â† Docs, shared tsconfig, biome config
```

**Absolute Prohibitions (FR-018 harness exception noted):**
- âš ï¸ Root `package.json` ONLY allowed for dev-only orchestration harnesses (e.g., Turborepo). Requirements:
  - Must be marked `"private": true`
  - May contain **devDependencies** only (no shared runtime deps)
  - Must reference backend/frontend via workspace paths without linking `node_modules`
  - Must delegate QA/lint/typecheck to existing Taskfile/Turborepo scripts so guardrails remain identical
- âŒ No root encore.app
- âŒ No shared node_modules
- âŒ No backendâ†”frontend imports
- âŒ No manual HTTP fetches (use Encore generated clients)

---

### ğŸ“› Naming Conventions (CRITICAL)

**Function names MUST be descriptive verb phrases:**
- âœ… `calculateTotalPrice`, `fetchUserProfile`, `saveScreenshot`, `handleDeviceConnection`
- âŒ `handle()`, `process()`, `doStuff()`, `manager()`

**Class names MUST be singular nouns or noun phrases:**
- âœ… `ScreenGraphProjector`, `AgentOrchestrator`, `RunEventPublisher`
- âŒ `Hasher`, `Mapper`, `Processor`, `Manager` (too generic)

**Domain-oriented, not tech-oriented:**
- âœ… `ScreenHasher`, `RunEventMapper`, `AgentStateProcessor`
- âŒ `Hasher`, `Mapper`, `Processor` (missing business context)

---

### ğŸ”’ Type Safety (NO EXCEPTIONS)

**Absolutely NO `any` type:**
- Every function, class, API endpoint MUST use explicit types
- DTOs (Data Transfer Objects) defined at top of file or imported
- Dynamic data â†’ `Record<string, unknown>` or `{ [key: string]: unknown }`
- Never fallback to `any`

**Typed APIs:**
- Always use Encore generated clients (`~encore/clients`)
- Never manual `fetch()` calls
- After backend changes â†’ run `bun run gen` on frontend
- Full end-to-end type safety guaranteed

**Encore.ts TypeScript Limitations:**
- âŒ **NO indexed access types**: `(typeof ARRAY)[number]` NOT supported by Encore parser
- âœ… **Use explicit literal unions instead**:

```typescript
// âŒ BAD: Encore parser fails on indexed access
export const STATUSES = ["pending", "active", "completed"] as const;
export type Status = (typeof STATUSES)[number];

// âœ… GOOD: Explicit literal union, then typed array
export type Status = "pending" | "active" | "completed";
export const STATUSES: readonly Status[] = ["pending", "active", "completed"];
```

**Examples:**
```typescript
interface StartRunRequest { appId: string; deviceId: string; policy?: "breadth" | "depth"; }
function startRun(req: StartRunRequest): Promise<RunResponse> {}
// BAD: avoid `any`
```

---

### ğŸ“ Documentation & Comments

**Every function, class, enum, DTO MUST have a purpose comment:**
```typescript
/** Calculates perceptual hash of a screenshot for deduplication. */
export function calculateScreenHash(image: Buffer): string {}
```

---

### ğŸš« No Magic Strings/Numbers

**Define literal unions or enums:**
```typescript
type AgentStatus = "idle" | "planning" | "acting" | "completed";
const RUN_STATUS = { ACTIVE: "active", CANCELED: "canceled", COMPLETED: "completed" } as const;
if (status === RUN_STATUS.ACTIVE) { /* ... */ }
```

---

### ğŸŒ Spelling & Language

**Use American English exclusively:**
- âœ… `canceled`, `color`, `optimize`, `initialize`
- âŒ `cancelled`, `colour`, `optimise`, `initialise`

**Applies to:** variable names, function names, enums, DB columns, types, comments, docs

---

### ğŸ“Š Logging Standards

**Use ONLY `encore.dev/log` (NEVER `console.log`):**
```typescript
import log from "encore.dev/log";

const logger = log.with({ module: "agent", actor: "worker", runId: "abc123" });
logger.info("state transition", { from: "idle", to: "planning" });
logger.error("device connection failed", { err: error.message, deviceId });
```

**Required fields:** `module`, `actor`, `runId` (when applicable)  
**On failures:** Include `stopReason` and `err.*` fields  
**Always structured JSON** â€” never unstructured strings

---

### ğŸ§ª Testing Philosophy

**Test for flow reliability and correctness:**
- High-level flow tests (not edge cases or petty tests)
- Focus on creative consistency
- Verify end-to-end behavior

**Commands:**
- Backend: `encore test`
- Frontend: `bun run test`

---

### ğŸ¯ API Clients

**Always use Encore generated clients:**
```typescript
import { run } from '~encore/clients';
const result = await run.start({ appId: 'com.example' });
// BAD: manual fetch
```

**Workflow:**
1. Update backend API endpoint
2. Run `bun run gen` in frontend
3. Use new types in frontend code
4. Full type safety end-to-end

---

### ğŸ“¦ Package Management

**Use Bun exclusively:**
- All projects: `"packageManager": "bun"`
- Backend: `cd backend && bun install`
- Frontend: `cd frontend && bun install`

---

### ğŸš€ Commands

**Backend:**
```bash
cd backend && encore run
```

**Frontend:**
```bash
cd frontend && bun run dev
```

**NEVER run from root** â€” always `cd` into service directory

**Skills vs Commands:**
- Deterministic automation lives in `.cursor/commands` and underlying scripts; treat them as the single source for repeatable shell workflows.
- `.claude-skills` entries describe conversational playbooks for Claude/or any other coding agent (Like You); they may call Task commands and MCP tools, but their job is human-facing orchestration and analysis.
- Add new rules about skill vs command usage here as soon as a workflow becomes canonical so the whole team stays aligned.
- Rule definition files must end with `_rules`; skill directories must end with `_skill` (the internal `SKILL.md` stays as-is); Task command descriptions in `.cursor/commands` must be natural language phrases of five words or fewer.
- If suffixing a document or skill cleanly isnâ€™t possible, fold its content into the appropriate consolidated artifact instead of forcing an exception.

---

### ğŸŒ Build & Deployment

**Backend:** Encore Cloud CI (no manual build scripts)  
**Frontend:** `vite build` â†’ Deploy to Vercel  
**Deploy independently** â€” backend and frontend are separate

---

### ğŸ“‹ Handoff Documentation

**Maintain these files at root:**
- `BACKEND_HANDOFF.md` â€” Backend architecture summary
- `FRONTEND_HANDOFF.md` â€” Frontend architecture summary

Update after significant changes.

---

## Part II: Environment Policy

### Single Environment Execution
- All local development uses the shared `.env` file checked into the repo.
- Standard ports: backend 4000, frontend 5173, dashboard 9400, appium 4723.
- Do not customize ports per worktree; treat `.env` as the source of truth.

### Worktree Usage
- Worktrees are for parallel code editing only. Run full tests/smoke checks on the main tree.
- Do not rely on worktree-specific automation (port offsets, isolation scripts, etc.).

### Standard Dev Commands
```bash
bun run dev          # Turborepo harness â†’ backend + frontend
cd backend && encore run   # Service-specific when needed
cd frontend && bun run dev # Service-specific when needed
```

### Services & Ports
- Scripts `./automation/scripts/dev-backend.sh` and `./automation/scripts/dev-frontend.sh` respect `.env` values.
- Husky/CI always start services on the standard ports defined above.

---

**Last Updated**: 2025-11-07
