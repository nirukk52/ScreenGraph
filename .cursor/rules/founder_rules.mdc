---
alwaysApply: true
description: "Non-negotiable development standards for ScreenGraph. Enforces architecture boundaries, naming conventions, type safety, American English spelling, logging standards, package management, and multi-agent worktree isolation policies."
---

# Founder Rules ‚Äî ScreenGraph Development Standards

> **Purpose**: Non-negotiable rules for all development. Enforce isolation, type safety, naming standards, and multi-agent worktree discipline.

---

## üìë Table of Contents

### Part I: Core Coding Standards
1. [Architecture & Boundaries](#architecture--boundaries)
2. [Naming Conventions](#naming-conventions-critical)
3. [Type Safety](#type-safety-no-exceptions)
4. [Documentation & Comments](#documentation--comments)
5. [No Magic Strings/Numbers](#no-magic-stringsnumbers)
6. [Spelling & Language](#spelling--language)
7. [Logging Standards](#logging-standards)
8. [Testing Philosophy](#testing-philosophy)
9. [API Clients](#api-clients)
10. [Package Management](#package-management)
11. [Commands](#commands)
12. [Build & Deployment](#build--deployment)
13. [Handoff Documentation](#handoff-documentation)
14. [Vibe Usage](#vibe-usage-engineering-personas)

15. [Knowledge Management](#knowledge-management-graphiti)

### Part II: Scripting Architecture & Policy
16. [Scripting Governance](#scripting-governance)
17. [Where Scripts Live](#where-scripts-live)
18. [Forbidden Practices](#forbidden-practices)

### Part III: Environment Policy
19. [Single Environment Execution](#single-environment-execution)
20. [Worktree Usage](#worktree-usage)
21. [Standard Ports](#standard-ports)
22. [Git Operations](#git-operations)

---

## Part I: Core Coding Standards (ALWAYS)

### üèóÔ∏è Architecture & Boundaries

**Backend/Frontend Separation:**
- Backend (`backend/`) and frontend (`frontend/`) are completely independent services
- No shared code or `node_modules` between them
- No root `package.json` or `encore.app`
- Backend never imports frontend; frontend never touches backend code
- No root-level coupling: root only holds docs and Git config

**Directory Structure:**
```
/ScreenGraph
‚îú‚îÄ‚îÄ backend/          ‚Üê Encore backend (independent)
‚îÇ   ‚îú‚îÄ‚îÄ encore.app
‚îÇ   ‚îú‚îÄ‚îÄ package.json
‚îÇ   ‚îî‚îÄ‚îÄ bun.lock
‚îú‚îÄ‚îÄ frontend/         ‚Üê SvelteKit frontend (independent)
‚îÇ   ‚îú‚îÄ‚îÄ package.json
‚îÇ   ‚îî‚îÄ‚îÄ bun.lock
‚îî‚îÄ‚îÄ README.md         ‚Üê Docs, shared tsconfig, biome config
```

**Absolute Prohibitions (FR-018 harness exception noted):**
- ‚ö†Ô∏è Root `package.json` ONLY allowed for dev-only orchestration harnesses (e.g., Turborepo). Requirements:
  - Must be marked `"private": true`
  - May contain **devDependencies** only (no shared runtime deps)
  - Must reference backend/frontend via workspace paths without linking `node_modules`
  - Must delegate QA/lint/typecheck to existing Taskfile/Turborepo scripts so guardrails remain identical
- ‚ùå No root encore.app
- ‚ùå No shared node_modules
- ‚ùå No backend‚Üîfrontend imports
- ‚ùå No manual HTTP fetches (use Encore generated clients)

---

### üìõ Naming Conventions (CRITICAL)

**Function names MUST be descriptive verb phrases:**
- ‚úÖ `calculateTotalPrice`, `fetchUserProfile`, `saveScreenshot`, `handleDeviceConnection`
- ‚ùå `handle()`, `process()`, `doStuff()`, `manager()`

**Class names MUST be singular nouns or noun phrases:**
- ‚úÖ `ScreenGraphProjector`, `AgentOrchestrator`, `RunEventPublisher`
- ‚ùå `Hasher`, `Mapper`, `Processor`, `Manager` (too generic)

**Domain-oriented, not tech-oriented:**
- ‚úÖ `ScreenHasher`, `RunEventMapper`, `AgentStateProcessor`
- ‚ùå `Hasher`, `Mapper`, `Processor` (missing business context)

---

### üîí Type Safety (NO EXCEPTIONS)

**Absolutely NO `any` type:**
- Every function, class, API endpoint MUST use explicit types
- DTOs (Data Transfer Objects) defined at top of file or imported
- Dynamic data ‚Üí `Record<string, unknown>` or `{ [key: string]: unknown }`
- Never fallback to `any`

**Typed APIs:**
- Always use Encore generated clients (`~encore/clients`)
- Never manual `fetch()` calls
- After backend changes ‚Üí run `bun run gen` on frontend
- Full end-to-end type safety guaranteed

**Encore.ts TypeScript Limitations:**
- ‚ùå **NO indexed access types**: `(typeof ARRAY)[number]` NOT supported by Encore parser
- ‚úÖ **Use explicit literal unions instead**:

```typescript
// ‚ùå BAD: Encore parser fails on indexed access
export const STATUSES = ["pending", "active", "completed"] as const;
export type Status = (typeof STATUSES)[number];

// ‚úÖ GOOD: Explicit literal union, then typed array
export type Status = "pending" | "active" | "completed";
export const STATUSES: readonly Status[] = ["pending", "active", "completed"];
```

**Examples:**
```typescript
interface StartRunRequest { appId: string; deviceId: string; policy?: "breadth" | "depth"; }
function startRun(req: StartRunRequest): Promise<RunResponse> {}
// BAD: avoid `any`
```

---

### üìù Documentation & Comments

**Every function, class, enum, DTO MUST have a purpose comment:**
```typescript
/** Calculates perceptual hash of a screenshot for deduplication. */
export function calculateScreenHash(image: Buffer): string {}
```

---

### üö´ No Magic Strings/Numbers

**Define literal unions or enums:**
```typescript
type AgentStatus = "idle" | "planning" | "acting" | "completed";
const RUN_STATUS = { ACTIVE: "active", CANCELED: "canceled", COMPLETED: "completed" } as const;
if (status === RUN_STATUS.ACTIVE) { /* ... */ }
```

---

### üåç Spelling & Language

**Use American English exclusively:**
- ‚úÖ `canceled`, `color`, `optimize`, `initialize`
- ‚ùå `cancelled`, `colour`, `optimise`, `initialise`

**Applies to:** variable names, function names, enums, DB columns, types, comments, docs

---

### üìä Logging Standards

**Use ONLY `encore.dev/log` (NEVER `console.log`):**
```typescript
import log from "encore.dev/log";

const logger = log.with({ module: "agent", actor: "worker", runId: "abc123" });
logger.info("state transition", { from: "idle", to: "planning" });
logger.error("device connection failed", { err: error.message, deviceId });
```

**Required fields:** `module`, `actor`, `runId` (when applicable)  
**On failures:** Include `stopReason` and `err.*` fields  
**Always structured JSON** ‚Äî never unstructured strings

---

### üß™ Testing Philosophy

**ABSOLUTE: NO TEST SKIPPING ALLOWED**
- ‚ùå Never skip, conditional, or reduce test scope in CI/CD or pre-commit hooks
- ‚ùå Never create workarounds to bypass test failures
- ‚úÖ ALL tests must pass before code can merge
- ‚úÖ If a test fails ‚Üí fix code or fix test (never disable test)
- ‚úÖ Test failures block PRs intentionally - this is correct behavior

**Test for flow reliability and correctness:**
- High-level flow tests (not edge cases or petty tests)
- Focus on creative consistency
- Verify end-to-end behavior

**Commands:**
- Backend: `encore test`
- Frontend: `bun run test`
- Full QA: `cd .cursor && task qa:all` (runs all 6 checks, no skipping)

---

### üéØ API Clients

**Always use Encore generated clients:**
```typescript
import { run } from '~encore/clients';
const result = await run.start({ appId: 'com.example' });
// BAD: manual fetch
```

**Workflow:**
1. Update backend API endpoint
2. Run `bun run gen` in frontend
3. Use new types in frontend code
4. Full type safety end-to-end

---

### üì¶ Package Management

**Use Bun exclusively:**
- All projects: `"packageManager": "bun"`
- Backend: `cd backend && bun install`
- Frontend: `cd frontend && bun install`

---

### üöÄ Commands

**Backend:**
```bash
cd backend && encore run
```

**Frontend:**
```bash
cd frontend && bun run dev
```

**NEVER run from root** ‚Äî always `cd` into service directory

**Skills vs Commands:**
- Deterministic automation lives in `.cursor/commands` and underlying scripts; treat them as the single source for repeatable shell workflows.
- `.claude-skills` entries describe conversational playbooks for Claude/or any other coding agent (Like You); they may call Task commands and MCP tools, but their job is human-facing orchestration and analysis.
- Add new rules about skill vs command usage here as soon as a workflow becomes canonical so the whole team stays aligned.
- Rule definition files must end with `_rules`; skill directories must end with `_skill` (the internal `SKILL.md` stays as-is); Task command descriptions in `.cursor/commands` must be natural language phrases of five words or fewer.
- If suffixing a document or skill cleanly isn‚Äôt possible, fold its content into the appropriate consolidated artifact instead of forcing an exception.

---

### üåê Build & Deployment

**Backend:** Encore Cloud CI (no manual build scripts)  
**Frontend:** `vite build` ‚Üí Deploy to Vercel  
**Deploy independently** ‚Äî backend and frontend are separate

---

### üìã Handoff Documentation

**Maintain these files at root:**
- `BACKEND_HANDOFF.md` ‚Äî Backend architecture summary
- `FRONTEND_HANDOFF.md` ‚Äî Frontend architecture summary

Update after significant changes.

---

### üé≠ Vibe Usage (Engineering Personas)

**ALWAYS load appropriate vibe before starting domain-specific work:**

**What are vibes?**
- Role-based profiles that configure AI agents with domain-specific MCP tools, documentation, Task commands, and workflow patterns
- Every vibe extends `base_vibe` (graphiti, context7, sequential-thinking)
- Located in `vibes/` directory

**Available Vibes:**
- **backend_vibe** ‚Äî Backend/API work (encore-mcp, github, backend-debugging)
- **frontend_vibe** ‚Äî Frontend/UI work (playwright, svelte, figma, vercel)
- **infra_vibe** ‚Äî DevOps/automation (mcp-builder, skill-creator, github, vercel)
- **qa_vibe** ‚Äî Testing/QA (playwright, encore-mcp, webapp-testing)

**Mandatory Workflow:**
```
1. BEFORE starting work: Load appropriate vibe
   "Load backend_vibe and [task]"
   "Load frontend_vibe and [task]"
   
2. DURING work:
   - Use vibe-specific MCP tools (not manual scripting)
   - Follow vibe-specific rules and documentation
   - Run vibe-recommended Task commands
   - Leverage vibe-specific Claude skills
   
3. AFTER completing:
   - Run quality checks (founder rules, tests, smoke tests)
   - Document discoveries via Graphiti
   - Update handoff docs if significant changes
```

**Examples:**
```
‚úÖ "Load backend_vibe and optimize agent state machine"
   ‚Üí Uses encore-mcp for introspection, backend-debugging skill

‚úÖ "Load frontend_vibe and build navigation component"
   ‚Üí Uses playwright for inspection, svelte docs, autofixer

‚úÖ "Load qa_vibe and write E2E tests for run flow"
   ‚Üí Uses webapp-testing skill, playwright automation

‚úÖ "Load infra_vibe and create Stripe MCP server"
   ‚Üí Uses @mcp-builder_skill 4-phase process
```

**MCP Tools Registry:**
- **Location:** `.cursor/mcp.json` (template) and `.cursor/mcp.local.json` (secrets, gitignored)
- All vibes reference tools from this registry
- To add new tool: Update mcp.json ‚Üí Update relevant vibe ‚Üí Document in Graphiti

**Enforcement:**
- ‚ùå Never work without loading appropriate vibe (you'll miss critical tools/context)
- ‚ùå Never ignore vibe-specific rules (they ensure consistency)
- ‚ùå Never skip Graphiti search before implementing (avoid reinventing)
- ‚úÖ ALWAYS search Graphiti for existing patterns before starting
- ‚úÖ ALWAYS document solutions via Graphiti after solving complex issues
- ‚úÖ ALWAYS use vibe-specific MCP tools instead of manual work

**See:** `vibes/README.md` for complete vibe documentation and decision tree

---

### üß† Knowledge Management (Graphiti)

**MANDATORY: 3-Command Structured Workflow**

AI agents MUST use the 3-command system at appropriate lifecycle points:

```
@before-task  [task]      ‚Üê Before starting (comprehensive discovery)
@during-task  [subtask]   ‚Üê During work (lightweight guidance)
@after-task   [completed] ‚Üê After completion (knowledge capture)
```

**Command details:**

1. **@before-task** (2500 tokens, 1√ó per spec):
   - Full Graphiti search for past work (`group_id="screengraph"`)
   - Vibe + MCP + skills recommendations
   - Architecture patterns and gotchas
   - Use BEFORE /speckit.specify or major work

2. **@during-task** (300 tokens, 5-10√ó per spec):
   - Quick MCP suggestions (no full search)
   - Brief workflow guidance
   - Use BEFORE implementing each subtask

3. **@after-task** (600 tokens, 1√ó per spec):
   - Document solution in Graphiti
   - Track MCP effectiveness
   - Use AFTER pre-push, BEFORE PR

**Token savings:** 82% (5.5k vs 30k per spec)  
**Knowledge retention:** 100% (mandatory documentation)

**MANDATORY: Graphiti-First Workflow**

Every AI agent MUST use Graphiti to avoid reinventing solutions and to build institutional knowledge.

**Before Starting ANY Task:**
1. ‚úÖ **Search Graphiti for existing patterns**
   ```
   search_memory_nodes(query="[topic]", max_nodes=10)
   search_memory_facts(query="[specific question]", max_facts=10)
   ```
2. ‚úÖ Review results for similar past work, solutions, gotchas
3. ‚úÖ Use Context7 if external library docs needed
4. ‚úÖ Proceed with implementation using domain-specific MCP tools

**During Complex Work:**
- ‚úÖ Document non-obvious decisions as you make them
- ‚úÖ Capture workarounds or gotchas immediately
- ‚úÖ Use sequential-thinking MCP for multi-step reasoning

**After Completing Task:**
1. ‚úÖ **Document solution via Graphiti**
   ```
   add_memory(
     name="[Feature/Bug/Pattern Name]",
     episode_body="Problem: ... Solution: ... Gotchas: ... Files: ...",
     group_id="screengraph",
     source="text"
   )
   ```
2. ‚úÖ Include: problem statement, solution approach, caveats, files touched
3. ‚úÖ Use tags/categories in episode_body for organization

**ScreenGraph Project Identifier:**

- ‚úÖ **ALWAYS use `group_id="screengraph"`** for ALL Graphiti operations
- ‚úÖ Graphiti is shared across multiple projects - group_id provides project isolation
- ‚úÖ Use descriptive tags in episode_body to categorize (backend, frontend, testing, appium, etc.)
- ‚ùå **NEVER use different group_ids** - ScreenGraph = `"screengraph"` always

**Example Queries:**
```typescript
// Before implementing agent recovery
search_memory_nodes({
  query: "agent state machine error handling",
  group_ids: ["screengraph"],
  max_nodes: 10
})

// Before fixing Appium issue
search_memory_facts({
  query: "WebDriver session timeout recovery",
  group_ids: ["screengraph"],
  max_facts: 10
})

// Before building UI component
search_memory_nodes({
  query: "Svelte 5 runes component patterns",
  group_ids: ["screengraph"],
  max_nodes: 5
})
```

**Example Documentation:**
```typescript
// After solving complex bug
add_memory({
  name: "Agent Stalls on Privacy Consent Dialog",
  episode_body: `
    [Tags: backend, agent, appium, debugging]
    
    Problem: Agent hangs when encountering privacy consent dialogs
    Root Cause: Policy engine doesn't handle modal dialogs
    Solution: Added pre-flight dialog detection + user intervention
    Gotchas: Must check for dialogs BEFORE starting policy execution
    Files: backend/agent/nodes/setup/EnsureDevice/device-check.ts
    Related: BUG-015
  `,
  group_id: "screengraph",
  source: "text"
})
```

**Enforcement:**
- ‚ùå Never implement without searching Graphiti first
- ‚ùå Never solve complex issues without documenting
- ‚ùå Never assume you're the first to encounter a problem
- ‚úÖ ALWAYS search ‚Üí reason ‚Üí implement ‚Üí document
- ‚úÖ ALWAYS use appropriate group_ids for discoverability
- ‚úÖ ALWAYS include file paths in documentation

**Integration with Skills:**
- See: `.claude-skills/graphiti-mcp-usage_skill/SKILL.md` for detailed workflow
- Use sequential-thinking MCP when analysis gets complex
- Document skill improvements back into Graphiti

---

## Part II: Scripting Architecture & Policy

### üîß Scripting Governance

**Single Source of Truth:**
- All automation flows through **four entry points** that all call `automation/` library
- No duplication across Husky, Taskfile, GitHub Actions, or Claude Skills
- Each script is both CLI tool AND reusable module (dual interface pattern)

**Four Authorized Entry Points:**

| Entry Point | Location | Use Case | Guardrail |
|------------|----------|----------|-----------|
| **Taskfile** | `.cursor/commands/` | Primary dev/CI entry | Task descriptions ‚â§ 5 words |
| **Husky Hooks** | `.husky/` | Git commit/push enforcement | Prevent bad commits/pushes |
| **GitHub Actions** | `.github/workflows/` | CI/CD pipeline | Automated on pull/push |
| **Claude Skills** | `.claude-skills/` | AI agent workflows | Call Tasks + MCP tools |

**All four layers call the same `automation/scripts/` library.** Never duplicate business logic.

---

### üìç Where Scripts Live

**‚úÖ AUTHORIZED Locations:**

1. **Central Authority: `automation/scripts/`**
   - Environment resolution (`env.mjs`)
   - Founder rules enforcement (`check-founder-rules.mjs`)
   - Documentation management (`cleanup-root-docs.mjs`)
   - **Rule**: Reusable modules with dual CLI + export interface
   - **Example**: `node automation/scripts/env.mjs status` OR `import { getPorts } from './automation/scripts/env.mjs'`

2. **Speckit Automation: `.specify/scripts/bash/`**
   - Spec creation (`create-new-feature.sh`)
   - Plan setup (`setup-plan.sh`)
   - Prerequisite checks (`check-prerequisites.sh`)
   - **Rule**: Bash scripts, used by spec-driven workflows
   - **Not part of standard dev cycle** ‚Äî only for spec-kit operations

3. **Service NPM Scripts: `backend/package.json` & `frontend/package.json`**
   - Service-level dev/test commands
   - **Rule**: Must delegate to service code, not orchestration
   - **Examples**: `dev`, `test`, `lint`, `build`

4. **Backend Inspection Tools: `backend/scripts/`**
   - Debugging utilities (`check-agent-state.ts`, `inspect-run.ts`)
   - **Rule**: Must be prefixed with `check-` or `inspect-` (not part of workflow)
   - **Purpose**: Ad-hoc investigation only

---

### ‚ùå Forbidden Practices

**NEVER create:**

1. **Free-floating shell scripts at root or in service roots**
   - ‚ùå `./run-something.sh`
   - ‚ùå `./backend/debug.sh`
   - ‚úÖ Either add to Taskfile OR put in `backend/scripts/check-*.sh`

2. **Helper scripts outside recognized locations**
   - ‚ùå `./helpers/my-script.sh`
   - ‚ùå `./scripts/utility.mjs`
   - ‚úÖ Either add to `automation/scripts/` (if reusable) OR backend/scripts/check-* (if debug-only)

3. **Service commands that duplicate automation logic**
   - ‚ùå Backend NPM script that reimplements `check-founder-rules.mjs`
   - ‚úÖ Backend NPM script that CALLS `node automation/scripts/check-founder-rules.mjs`

4. **Inline scripts in Taskfiles without module exports**
   - ‚ùå Complex bash logic directly in task YAML
   - ‚úÖ Extract to `automation/scripts/` module, call from Taskfile

5. **Scripts with no CLI interface (import-only)**
   - ‚ùå Module that only works as `import { fn } from './script.mjs'`
   - ‚úÖ Both: `node script.mjs [command]` AND `import { fn } from './script.mjs'`

---

### üìã Script Design Requirements

**Every script MUST have:**

| Requirement | Example |
|-------------|---------|
| **Purpose comment** | `// Validates all Founder Rules before commits` |
| **CLI usage** | Works when run directly: `node check-founder-rules.mjs` |
| **Module exports** | `export function checkNoConsoleLog()` for reuse |
| **Exit codes** | `0` = success, `1` = failure |
| **Human-friendly output** | JSON-compatible but readable by default |
| **Optional `--json` flag** | `node script.mjs --json` for machine parsing |
| **Documentation** | Listed in `automation/README.md` or task description |

**Example Pattern:**
```javascript
#!/usr/bin/env node
// Purpose: Check for console.log violations in TypeScript files

export async function checkNoConsoleLog() {
  // Implementation
  return { violations: [...], passed: boolean };
}

// CLI interface
if (import.meta.url === `file://${process.argv[1]}`) {
  const result = await checkNoConsoleLog();
  console.log(result.passed ? '‚úÖ All checks passed' : '‚ùå Violations found');
  process.exit(result.passed ? 0 : 1);
}
```

---

### üéØ Common Patterns

**Adding New Automation:**

1. **Is it recurring?** ‚Üí Add to `automation/scripts/` (reusable + CLI)
2. **Is it service-specific?** ‚Üí Add to service NPM scripts
3. **Is it debug-only?** ‚Üí Add to `backend/scripts/check-*.ts` or `inspect-*.ts`
4. **Is it one-time?** ‚Üí Put in `.specify/scripts/` (spec-kit only)

**Calling Automation From Different Layers:**

```yaml
# Taskfile: call automation script
tasks:
  preflight:
    cmds:
      - node ../automation/scripts/check-founder-rules.mjs
```

```bash
# Husky hook: call automation script
#!/bin/sh
node automation/scripts/check-founder-rules.mjs
```

```json
// NPM script: delegate to automation
"scripts": {
  "check:rules": "node ../automation/scripts/check-founder-rules.mjs"
}
```

```yaml
# GitHub Action: call automation script
- name: Validate
  run: node automation/scripts/check-founder-rules.mjs
```

---

## Part III: Environment Policy

### Single Environment Execution
- All local development uses the shared `.env` file checked into the repo.
- Standard ports: backend 4000, frontend 5173, dashboard 9400, appium 4723.
- Do not customize ports per worktree; treat `.env` as the source of truth.

### Worktree Usage
- Worktrees are for parallel code editing only. Run full tests/smoke checks on the main tree.
- Do not rely on worktree-specific automation (port offsets, isolation scripts, etc.).

### Standard Dev Commands
```bash
bun run dev          # Turborepo harness ‚Üí backend + frontend
cd backend && encore run   # Service-specific when needed
cd frontend && bun run dev # Service-specific when needed
```

### Services & Ports
- Scripts `./automation/scripts/dev-backend.sh` and `./automation/scripts/dev-frontend.sh` respect `.env` values.
- Husky/CI always start services on the standard ports defined above.

### Git Operations

**CRITICAL: Git commits and pushes require explicit founder approval**

- ‚ùå **NEVER commit changes** unless the founder explicitly says "commit" or "commit this" in the prompt
- ‚ùå **NEVER push changes** unless the founder explicitly says "push" or "push this" in the prompt
- ‚ùå **NEVER run `git commit`** proactively, even if you think the work is complete
- ‚ùå **NEVER stage files** (`git add`) unless explicitly requested

**Rationale:**
- The founder controls when code is committed to history
- Commits are permanent and must be intentional
- AI agents should implement changes, not decide when they're "done"
- Pre-commit hooks may have side effects that need manual oversight

**Violation:** If you commit or push without explicit founder approval, you are being too proactive and overstepping boundaries.

---

**CRITICAL: Always create a new branch for new work**

- ‚úÖ **ALWAYS create a new branch** before starting any new feature, bug fix, or task
- ‚úÖ Branch naming: `[type]-[description]` (e.g., `feature-agent-recovery`, `bug-session-timeout`, `chore-update-deps`)
- ‚úÖ Branch from latest main/master: `git checkout main && git pull && git checkout -b [branch-name]`
- ‚ùå **NEVER work directly on main/master branch**
- ‚ùå **NEVER commit to main/master** unless it's a hotfix explicitly approved by founder

**Branch Types:**
- `feature-*` ‚Üí New features
- `bug-*` ‚Üí Bug fixes
- `chore-*` ‚Üí Maintenance, refactoring, docs
- `test-*` ‚Üí Test infrastructure
- `spec-*` ‚Üí Spec-driven development (from `.specify/`)

**Rationale:**
- Isolates work and enables clean PRs
- Protects main branch from WIP commits
- Enables parallel work streams without conflicts
- Facilitates code review and rollback

**Example Workflow:**
```bash
# Start new work
git checkout main
git pull
git checkout -b feature-appium-lifecycle

# ... do work ...

# When ready (founder approval required)
git add .
git commit -m "feat: automate appium lifecycle"
git push origin feature-appium-lifecycle
```

---

**Last Updated**: 2025-11-13
